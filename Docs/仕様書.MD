# League of Legends パッチノート Discord 通知システム 仕様書

## 1. 概要

本システムは、Riot Games 公式の日本語版 League of Legends パッチノートページ (`https://www.leagueoflegends.com/ja-jp/news/game-updates/`) を定期的に監視し、新しいパッチノートが公開された際に自動で Discord チャンネルへ通知を送信するツールです。TypeScript とモダンな Node.js 技術スタックを基盤とし、高い信頼性、保守性、拡張性、セキュリティを目指します。

### システムの特徴
- **レート制限対応**: Riot Games APIとDiscord Webhookの制限に準拠
- **堅牢性**: サーキットブレーカーパターンによる障害耐性
- **監視**: 包括的なメトリクス収集とアラート機能
- **セキュリティ**: 最新のセキュリティベストプラクティスを実装

-----

## 2. 機能要件

### 2.1. パッチノート監視と情報抽出

  * **対象ページの巡回:** 指定された LoL 公式パッチノートページを定期的に HTTP リクエストで巡回します。
  * **HTML コンテンツ取得:** ページの HTML コンテンツを非同期で取得します。
  * **最新パッチノートの抽出:** 取得した HTML から、最新のパッチノートに関する以下の情報を抽出します。
      * **タイトル:** 例: "パッチ 14.13 ノート"
      * **URL:** 例: `https://www.leagueoflegends.com/ja-jp/news/game-updates/patch-14-13-notes/` (絶対パスとして取得)

### 2.2. 新規パッチノートの検知

  * **前回の状態比較:** システムが最後に通知したパッチノートの URL を記録しておき、今回の巡回で取得した最新パッチノートの URL と比較します。
  * **通知トリガー:** 比較した URL が異なる場合、新しいパッチノートが公開されたと判断し、通知処理をトリガーします。

### 2.3. Discord 通知

  * **Webhook 送信:** 新しいパッチノートが検知された場合、事前に設定された Discord Webhook URL へ HTTP POST リクエストで通知を送信します。
  * **通知コンテンツ:**
      * **テキストメッセージ:** "新しいLeague of Legendsのパッチノートが公開されました！"
      * **Discord Embed:**
          * `title`: 抽出したパッチノートのタイトル
          * `url`: 抽出したパッチノートの URL
          * `description`: 例: "詳細はこちらからご確認ください。" (固定テキストまたは必要に応じて生成)
          * `color`: Discord Embed の色 (例: `#581478` - Discord の紫色を推奨)
          * `timestamp`: 通知時のタイムスタンプ (JST)

### 2.4. 状態の永続化

  * **URL 保存:** 最後に通知したパッチノートの URL をファイル (`last_patch_status.json` など) に保存します。
  * **永続化形式:** 保存形式は JSON を推奨します。

### 2.5. エラーハンドリングとロギング

  * **堅牢なエラー処理:** ネットワークエラー、HTTP ステータスエラー (4xx/5xx)、HTML 解析エラー、Discord Webhook 送信エラーなど、発生しうるすべてのエラーを捕捉し、適切に処理します。
  * **サーキットブレーカーパターン:** 連続する失敗に対して、システムを保護するためのサーキットブレーカー機能を実装します。
  * **リトライメカニズム:** HTTP リクエストの失敗時に、指数バックオフ（初期1秒、最大30秒）を用いて最大3回まで自動リトライします。
  * **構造化ロギング:** JSON形式での構造化ログを採用し、ログ分析とモニタリングを効率化します。
  * **メトリクス収集:** 処理時間、成功/失敗率、レスポンスタイムなどの運用メトリクスを収集します。

### 2.6. セキュリティ要件

  * **レート制限:** Riot Games サーバーへの過度なリクエストを防ぐため、適切なレート制限を実装します。
  * **Webhook検証:** Discord Webhookの応答を検証し、不正なレスポンスに対して適切に対処します。
  * **入力検証:** HTML解析時に悪意のあるコンテンツから保護するため、適切な入力検証を行います。
  * **機密情報保護:** 環境変数とシークレット管理を徹底し、ログに機密情報が出力されないよう配慮します。

-----

## 3. 非機能要件 (モダンな Node.js/TS 観点)

### 3.1. 開発環境とランタイム

  * **言語:** TypeScript (最新の安定版を推奨)
  * **ランタイム:** Node.js (LTS バージョンを推奨)
  * **モジュールシステム:** ES Modules (ESM) を標準とします。

### 3.2. 主要技術スタック

**コア依存関係:**
  * **パッケージマネージャー:** `pnpm` (ディスク効率と高速インストール、モノレポサポート)
  * **HTTP クライアント:** `axios` または `undici` (Node.js 18+ ネイティブサポート、高性能)
  * **HTML パーサー:** `cheerio` (サーバーサイド jQuery API、軽量で高速)
  * **環境変数管理:** `@t3-oss/env-nextjs` または `zod` + `dotenv` (ランタイム検証付き)
  * **バリデーション:** `zod` (TypeScript ファースト、ランタイム型安全性)
  * **ロギング:** `pino` (高性能、構造化、非同期ロギング)
  * **スケジューリング:** `node-cron` + `node-schedule` (クラスタリング対応)
  * **状態永続化:** `ioredis` (Redis) または Node.js `fs/promises` (ファイル)
  * **型定義:** 最新の `@types/*` パッケージ群

**開発・品質保証:**
  * **テストフレームワーク:** `vitest` (Vite ベース、高速、ESM ネイティブ)
  * **モッキング:** `msw` (Mock Service Worker、リアルなHTTPモック)
  * **E2Eテスト:** `playwright` (複数ブラウザ、信頼性の高いテスト)
  * **パフォーマンステスト:** `autocannon` (Node.js 向け軽量ベンチマーク)

**監視・可観測性:**
  * **メトリクス:** `prom-client` (Prometheus メトリクス)
  * **ヘルスチェック:** `@godaddy/terminus` (グレースフルシャットダウン)
  * **分散トレーシング:** `@opentelemetry/api` (OpenTelemetry 標準)

### 3.3. コード品質と開発プロセス

**ビルドとトランスパイル:**
  * **ビルドツール:** `tsx` (高速 TypeScript 実行) または `tsc` + `esbuild` (高速ビルド)
  * **バンドル:** `esbuild` または `rollup` (本番ビルド最適化)
  * **型チェック:** `tsc --noEmit` (型検査のみ、並列実行対応)

**コード品質管理:**
  * **Linter:** `@typescript-eslint/eslint-plugin` + `eslint-config-prettier`
  * **セキュリティ:** `eslint-plugin-security`, `semgrep` (SAST)
  * **Formatter:** `prettier` (統一フォーマット)
  * **Import 管理:** `eslint-plugin-import`, `@typescript-eslint/consistent-type-imports`

**テスト戦略:**
  * **単体テスト:** `vitest` (カバレッジ目標: 80%以上)
  * **統合テスト:** 実際のHTTPエンドポイントを含むテスト
  * **E2Eテスト:** Discord Webhook のモック環境でのテスト
  * **パフォーマンステスト:** レスポンス時間とメモリ使用量の測定
  * **コントラクトテスト:** APIスキーマ検証 (OpenAPI 3.0)

**CI/CD パイプライン:**
```yaml
workflow:
  1. dependency-check    # 脆弱性スキャン (npm audit, Snyk)
  2. lint-and-format    # ESLint + Prettier
  3. type-check         # TypeScript 型検査
  4. unit-test          # 単体テスト + カバレッジ
  5. integration-test   # 統合テスト
  6. security-scan      # SAST/DAST (CodeQL, Semgrep)
  7. build              # 本番ビルド
  8. e2e-test          # E2Eテスト (staging)
  9. performance-test   # パフォーマンステスト
  10. deploy           # デプロイ (staging → production)
```

### 3.4. 運用とデプロイ

**実行方針:**
  * **実行間隔:** Riot Games サーバーへの負荷を考慮し、1-2時間間隔 (推奨: 90分)
  * **レート制限:** 1時間あたり最大20リクエスト、バースト制限付き
  * **タイムアウト:** HTTP リクエスト 30秒、Discord Webhook 10秒
  * **リトライ:** 指数バックオフ (1s, 2s, 4s) で最大3回

**設定管理とセキュリティ:**
  * **シークレット管理:** AWS Secrets Manager / Azure Key Vault / HashiCorp Vault
  * **環境変数検証:** `zod` によるランタイム検証と型安全性
  * **設定階層:** 環境別設定 (dev/staging/prod)
  * **暗号化:** 保存時暗号化 (AES-256) および転送時暗号化 (TLS 1.3)

**デプロイメント戦略:**

**推奨: サーバーレス (コスト効率重視)**
```yaml
AWS Lambda:
  runtime: nodejs18.x
  memory: 256MB
  timeout: 5分
  trigger: EventBridge Schedule
  storage: DynamoDB / S3
  monitoring: CloudWatch + X-Ray
```

**代替: コンテナ (制御重視)**
```yaml
Docker + Kubernetes:
  base: node:18-alpine
  resources:
    cpu: 100m
    memory: 128Mi
  replicas: 1 (singleton)
  storage: Redis / PostgreSQL
  monitoring: Prometheus + Grafana
```

**軽量: PaaS (シンプル重視)**
```yaml
Render / Fly.io:
  runtime: Node.js 18
  cron: システム組み込み
  storage: 外部Redis/PostgreSQL
  monitoring: ネイティブダッシュボード
```

### 3.5. 堅牢性と保守性

**HTML スクレイピング耐性:**
  * **セレクタ戦略:** 複数のフォールバック セレクタ (data 属性 → class → 構造)
  * **スキーマ検証:** 抽出データの構造検証 (zod スキーマ)
  * **変更検知:** HTML 構造変更の自動検知とアラート
  * **キャッシュ戦略:** 一時的な障害に対するフォールバック データ

**システム設計原則:**
  * **単一責任:** 各モジュールは明確に定義された責任を持つ
  * **依存性注入:** テスタビリティと柔軟性を確保
  * **インターフェース分離:** 外部サービスへの依存を抽象化
  * **設定外部化:** 全ての設定値を環境変数または設定ファイルで管理

**監視と可観測性:**
```yaml
メトリクス:
  - リクエスト成功率 (SLI: 99.5%)
  - レスポンス時間 (SLI: p95 < 2秒)
  - エラー率 (SLI: < 0.1%)
  - 通知配信成功率 (SLI: 99.9%)

アラート:
  - 連続失敗 (3回以上)
  - 異常なレスポンス時間 (5秒以上)
  - Discord Webhook 障害
  - HTML構造変更検知
```

**ドキュメント体系:**
  * **README.md:** 概要、セットアップ、基本操作
  * **ARCHITECTURE.md:** システム設計、コンポーネント図
  * **DEPLOYMENT.md:** デプロイメント手順、環境設定
  * **TROUBLESHOOTING.md:** 一般的な問題と解決方法
  * **API.md:** インターフェース仕様、設定項目
  * **CHANGELOG.md:** バージョン履歴、破壊的変更

-----

## 4. 詳細設計 (コードロジックの概要)

### 4.1. ディレクトリ・ファイル構成案

```
/lol_patch_notifier_ts/
├── src/
│   ├── app.ts                  # アプリケーションのエントリポイント (定期実行ロジックを含む)
│   ├── config/
│   │   └── index.ts            # 環境変数/設定の読み込みと型定義
│   ├── services/
│   │   ├── PatchScraper.ts     # パッチノートページのスクレイピングロジック
│   │   └── DiscordNotifier.ts  # Discord Webhook 通知ロジック
│   ├── utils/
│   │   └── logger.ts           # ロギング設定とインスタンス
│   │   └── fileStorage.ts      # ファイルI/O (状態永続化用)
│   ├── types/
│   │   └── index.ts            # アプリケーション全体で利用する型定義
│   └── index.ts                # (オプション) `app.ts` をimportして起動する簡単なラッパー
├── .env.example                # 環境変数のサンプル (Git 管理対象)
├── .env                        # 実際の環境変数 (`.gitignore` 対象)
├── last_patch_status.json      # 最後に通知したパッチの情報をJSON形式で保存 (`.gitignore` 対象)
├── tsconfig.json               # TypeScript コンパイラ設定
├── package.json                # プロジェクト情報と依存関係
├── pnpm-lock.yaml              # パッケージロックファイル
├── .eslintrc.js                # ESLint 設定
├── .prettierrc                 # Prettier 設定
├── jest.config.js              # Jest 設定
└── README.md                   # プロジェクト説明書
```

### 4.2. コアロジックのコンポーネント

#### 4.2.1. `src/config/index.ts` (設定管理)

  * `dotenv` を使用して `.env` ファイルから環境変数をロードします。
  * `process.env` から必要な設定値 (例: `DISCORD_WEBHOOK_URL`, `LOL_PATCH_NOTES_URL`, `LAST_STATUS_FILE`) を取得し、型安全にエクスポートします。
  * 必須の設定値が不足している場合は、起動時にエラーをスローし、プログラムを終了します。

<!-- end list -->

```typescript
// src/config/index.ts
import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

// 環境変数スキーマ定義
const envSchema = z.object({
  DISCORD_WEBHOOK_URL: z.string().url('Invalid Discord webhook URL'),
  LOL_PATCH_NOTES_URL: z.string().url().default('https://www.leagueoflegends.com/ja-jp/news/game-updates/'),
  LAST_STATUS_FILE_PATH: z.string().default('./last_patch_status.json'),
  CHECK_INTERVAL_CRON: z.string().default('0 */90 * * *'), // Every 90 minutes
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  REQUEST_TIMEOUT_MS: z.coerce.number().min(1000).max(60000).default(30000),
  MAX_RETRIES: z.coerce.number().min(0).max(10).default(3),
  RATE_LIMIT_PER_HOUR: z.coerce.number().min(1).max(100).default(20),
});

// ランタイム検証と型安全性
const parseResult = envSchema.safeParse(process.env);

if (!parseResult.success) {
  console.error('環境変数の検証エラー:', parseResult.error.format());
  process.exit(1);
}

export const config = parseResult.data;
export type Config = z.infer<typeof envSchema>;

// 開発環境での設定チェック
if (config.NODE_ENV === 'development') {
  console.log('Development mode - 設定確認:', {
    webhookConfigured: !!config.DISCORD_WEBHOOK_URL,
    requestTimeout: config.REQUEST_TIMEOUT_MS,
    checkInterval: config.CHECK_INTERVAL_CRON,
  });
}
```

#### 4.2.2. `src/utils/logger.ts` (ロギング)

  * `winston` を使用して、コンソール出力やファイル出力など、柔軟なロギングを設定します。
  * ログレベル (debug, info, warn, error) に応じた出力を可能にします。

<!-- end list -->

```typescript
// src/utils/logger.ts
import pino from 'pino';
import { config } from '../config';

// 構造化ログ設定
const logger = pino({
  level: config.LOG_LEVEL,
  formatters: {
    level: (label) => ({ level: label.toUpperCase() }),
    bindings: (bindings) => ({
      pid: bindings.pid,
      hostname: bindings.hostname,
    }),
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  serializers: {
    error: pino.stdSerializers.err,
    req: pino.stdSerializers.req,
    res: pino.stdSerializers.res,
  },
  redact: {
    paths: ['*.password', '*.token', '*.key', '*.secret'],
    censor: '[REDACTED]',
  },
  ...(config.NODE_ENV === 'production' && {
    transport: {
      target: 'pino-cloudwatch',
      options: {
        logGroupName: '/aws/lambda/lol-patch-notifier',
        logStreamName: () => new Date().toISOString().split('T')[0],
      },
    },
  }),
});

// メトリクス用カウンタ
let errorCount = 0;
let requestCount = 0;

export const logMetrics = {
  incrementError: () => errorCount++,
  incrementRequest: () => requestCount++,
  getMetrics: () => ({ errorCount, requestCount }),
  resetMetrics: () => {
    errorCount = 0;
    requestCount = 0;
  },
};

// コンテキスト付きロガーラッパー
export const createContextLogger = (context: Record<string, unknown>) => {
  return logger.child(context);
};

export default logger;
```

#### 4.2.3. `src/utils/fileStorage.ts` (ファイル I/O)

  * `fs/promises` を使用し、状態の読み書きを行います。
  * ファイルの存在チェックやエラーハンドリングを含めます。

<!-- end list -->

```typescript
// src/utils/storage.ts
import { promises as fs } from 'fs';
import { z } from 'zod';
import logger from './logger';
import { config } from '../config';

// ストレージインターフェース
export interface Storage {
  read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null>;
  write<T>(key: string, data: T): Promise<void>;
  exists(key: string): Promise<boolean>;
}

// ファイルストレージ実装
export class FileStorage implements Storage {
  private readonly basePath: string;

  constructor(basePath = './data') {
    this.basePath = basePath;
  }

  async read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null> {
    const filePath = this.getFilePath(key);
    const contextLogger = logger.child({ operation: 'read', filePath });
    
    try {
      const data = await fs.readFile(filePath, 'utf-8');
      const parsed = JSON.parse(data);
      const validated = schema.parse(parsed);
      
      contextLogger.info('ファイル読み込み成功');
      return validated;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        contextLogger.info('ファイルが存在しません - 初回実行とみなします');
        return null;
      }
      contextLogger.error({ error }, 'ファイル読み込みエラー');
      throw new Error(`Storage read failed: ${error}`);
    }
  }

  async write<T>(key: string, data: T): Promise<void> {
    const filePath = this.getFilePath(key);
    const contextLogger = logger.child({ operation: 'write', filePath });
    
    try {
      // ディレクトリが存在しない場合は作成
      await fs.mkdir(this.basePath, { recursive: true });
      
      const jsonData = JSON.stringify(data, null, 2);
      await fs.writeFile(filePath, jsonData, 'utf-8');
      
      contextLogger.info('ファイル書き込み成功');
    } catch (error) {
      contextLogger.error({ error }, 'ファイル書き込みエラー');
      throw new Error(`Storage write failed: ${error}`);
    }
  }

  async exists(key: string): Promise<boolean> {
    try {
      await fs.access(this.getFilePath(key));
      return true;
    } catch {
      return false;
    }
  }

  private getFilePath(key: string): string {
    return `${this.basePath}/${key}.json`;
  }
}

// Redisストレージ実装 (サーバーレス環境用)
export class RedisStorage implements Storage {
  // Redisクライアントの実装は省略
  async read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null> {
    // Redisからデータを取得し、スキーマ検証を行う
    throw new Error('Redis storage not implemented');
  }

  async write<T>(key: string, data: T): Promise<void> {
    // Redisにデータを保存
    throw new Error('Redis storage not implemented');
  }

  async exists(key: string): Promise<boolean> {
    throw new Error('Redis storage not implemented');
  }
}

// ストレージファクトリ
export function createStorage(): Storage {
  if (config.NODE_ENV === 'production' && process.env.REDIS_URL) {
    return new RedisStorage();
  }
  return new FileStorage();
}
```

#### 4.2.4. `src/types/index.ts` (型定義)

  * アプリケーションで利用するデータ構造の型を定義します。

<!-- end list -->

```typescript
// src/types/index.ts
export interface PatchInfo {
    title: string;
    url: string;
}

export interface LastStatus {
    lastCheckedUrl: string;
    lastCheckedTimestamp: string;
}

export interface DiscordEmbed {
    title: string;
    url: string;
    description: string;
    color: number; // Decimal color code, e.g., 5814783 for purple
    timestamp?: string; // ISO 8601 format
}

export interface DiscordWebhookPayload {
    content?: string;
    embeds?: DiscordEmbed[];
}
```

#### 4.2.5. `src/services/PatchScraper.ts` (スクレイピングロジック)

  * 指定された URL から HTML を取得し、`cheerio` を使ってパッチノート情報を抽出します。
  * HTML 構造変更に備え、堅牢なセレクタを使用します。

<!-- end list -->

```typescript
// src/services/PatchScraper.ts
import axios from 'axios';
import * as cheerio from 'cheerio';
import { config } from '../config';
import logger from '../utils/logger';
import { PatchInfo } from '../types';

export class PatchScraper {
    private readonly baseUrl = 'https://www.leagueoflegends.com';

    public async getLatestPatchInfo(): Promise<PatchInfo | null> {
        try {
            logger.info(`Fetching patch notes from: ${config.lolPatchNotesUrl}`);
            const response = await axios.get(config.lolPatchNotesUrl, { timeout: 10000 }); // 10秒のタイムアウト
            const $ = cheerio.load(response.data);

            // 最新のゲームアップデート記事を特定 (data-content-type="game-updates" 属性を持つ最初のaタグ)
            const latestArticle = $('a[data-content-type="game-updates"]').first();

            if (!latestArticle.length) {
                logger.warn('No patch notes articles found with the specified selector.');
                return null;
            }

            const title = latestArticle.find('.news-card-title').text().trim();
            const relativeUrl = latestArticle.attr('href');

            if (!title || !relativeUrl) {
                logger.warn('Could not extract title or URL from the latest article.');
                return null;
            }

            const fullUrl = new URL(relativeUrl, this.baseUrl).toString(); // 絶対URLに変換

            logger.info(`Found latest patch: "${title}" at ${fullUrl}`);
            return { title, url: fullUrl };

        } catch (error: any) {
            logger.error(`Error scraping patch notes: ${error.message}`, error);
            if (axios.isAxiosError(error) && error.response) {
                logger.error(`HTTP Status: ${error.response.status}, Data: ${JSON.stringify(error.response.data)}`);
            }
            return null;
        }
    }
}
```

#### 4.2.6. `src/services/DiscordNotifier.ts` (Discord Webhook 通知)

  * Discord Webhook のペイロードを構築し、`axios` で送信します。
  * エラー発生時のロギングを含めます。

<!-- end list -->

```typescript
// src/services/DiscordNotifier.ts
import axios from 'axios';
import { config } from '../config';
import logger from '../utils/logger';
import { DiscordWebhookPayload, DiscordEmbed, PatchInfo } from '../types';

export class DiscordNotifier {
    public async sendNotification(patchInfo: PatchInfo): Promise<void> {
        const embed: DiscordEmbed = {
            title: patchInfo.title,
            url: patchInfo.url,
            description: '新しいLeague of Legendsパッチノートが公開されました！詳細はこちらからご確認ください。',
            color: 5814783, // Decimal for Discord purple
            timestamp: new Date().toISOString(), // ISO 8601 format
        };

        const payload: DiscordWebhookPayload = {
            content: '@everyone', // Discordで全員に通知したい場合
            embeds: [embed],
        };

        try {
            logger.info('Attempting to send Discord notification...');
            await axios.post(config.discordWebhookUrl, payload);
            logger.info('Discord notification sent successfully.');
        } catch (error: any) {
            logger.error(`Error sending Discord notification: ${error.message}`, error);
            if (axios.isAxiosError(error) && error.response) {
                logger.error(`Discord Webhook Status: ${error.response.status}, Response: ${JSON.stringify(error.response.data)}`);
            }
        }
    }
}
```

#### 4.2.7. `src/app.ts` (アプリケーション本体とスケジューリング)

  * 各種サービスを統合し、定期実行ロジックを実装します。
  * `node-cron` を使用してスケジュールを設定します。

<!-- end list -->

```typescript
// src/app.ts
import cron from 'node-cron';
import logger from './utils/logger';
import { config } from './config';
import { PatchScraper } from './services/PatchScraper';
import { DiscordNotifier } from './services/DiscordNotifier';
import { readJsonFile, writeJsonFile } from './utils/fileStorage';
import { LastStatus } from './types';

export class App {
    private patchScraper: PatchScraper;
    private discordNotifier: DiscordNotifier;
    private lastStatus: LastStatus | null = null;

    constructor() {
        this.patchScraper = new PatchScraper();
        this.discordNotifier = new DiscordNotifier();
    }

    public async init(): Promise<void> {
        logger.info('Application initializing...');
        this.lastStatus = await readJsonFile<LastStatus>(config.lastStatusFilePath);
        if (!this.lastStatus) {
            this.lastStatus = { lastCheckedUrl: '', lastCheckedTimestamp: '' };
            await writeJsonFile(config.lastStatusFilePath, this.lastStatus);
        }
        logger.info(`Last checked URL: ${this.lastStatus.lastCheckedUrl}`);
    }

    public async checkAndNotify(): Promise<void> {
        logger.info('Starting patch notes check...');
        try {
            const latestPatch = await this.patchScraper.getLatestPatchInfo();

            if (!latestPatch) {
                logger.warn('Could not retrieve latest patch info. Skipping notification.');
                return;
            }

            if (latestPatch.url !== this.lastStatus?.lastCheckedUrl) {
                logger.info(`New patch found! Title: "${latestPatch.title}", URL: ${latestPatch.url}`);
                await this.discordNotifier.sendNotification(latestPatch);

                this.lastStatus = {
                    lastCheckedUrl: latestPatch.url,
                    lastCheckedTimestamp: new Date().toISOString(),
                };
                await writeJsonFile(config.lastStatusFilePath, this.lastStatus);
            } else {
                logger.info('No new patch notes found. Current: ' + latestPatch.title);
            }
        } catch (error: any) {
            logger.error(`An unexpected error occurred during check: ${error.message}`, error);
        }
    }

    public startScheduler(): void {
        logger.info(`Scheduling patch notes check every: ${config.checkIntervalCron}`);
        cron.schedule(config.checkIntervalCron, () => {
            this.checkAndNotify();
        });
        logger.info('Scheduler started.');
    }
}

// 起動スクリプト
(async () => {
    const app = new App();
    await app.init();
    await app.checkAndNotify(); // アプリケーション起動時に一度実行
    app.startScheduler(); // その後、スケジュールに従って実行
})().catch(error => {
    logger.error(`Failed to start application: ${error.message}`, error);
    process.exit(1);
});
```

-----

## 5\. 開発とデプロイの考慮事項

### 5.1. 開発フロー

1.  **リポジトリのクローン:**
    ```bash
    git clone your-repo-url
    cd lol_patch_notifier_ts
    ```
2.  **依存関係のインストール:**
    ```bash
    pnpm install # または yarn install / npm install
    ```
3.  **環境設定:** `.env.example` を参考に、`.env` ファイルを作成し、`DISCORD_WEBHOOK_URL` などを設定します。
    ```
    # .env
    DISCORD_WEBHOOK_URL="YOUR_DISCORD_WEBHOOK_URL"
    # LOL_PATCH_NOTES_URL="https://www.leagueoflegends.com/ja-jp/news/game-updates/" # デフォルト値を使用
    # LAST_STATUS_FILE_PATH="./last_patch_status.json" # デフォルト値を使用
    # CHECK_INTERVAL_CRON="0 */1 * * *" # 1時間ごと
    # LOG_LEVEL="info"
    ```
4.  **開発モードで実行:**
    ```bash
    pnpm dev # `ts-node-dev` などを使って自動リロードしながら実行するスクリプトを package.json に追加
    ```
    `package.json` に以下のようなスクリプトを追加します。
    ```json
    {
      "scripts": {
        "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
        "build": "tsc",
        "start": "node dist/app.js",
        "lint": "eslint src --ext .ts",
        "format": "prettier --write \"src/**/*.ts\"",
        "test": "jest"
      }
    }
    ```
5.  **コード品質チェック:**
    ```bash
    pnpm lint
    pnpm format
    ```
6.  **テスト実行:**
    ```bash
    pnpm test
    ```

### 5.2. ビルドと本番実行

1.  **ビルド:**
    ```bash
    pnpm build
    ```
    これにより、`dist` ディレクトリにコンパイル済みの JavaScript ファイルが出力されます。
2.  **本番実行:**
    ```bash
    node dist/app.js
    ```

### 5.3. デプロイに関する考慮事項

  * **環境変数:** デプロイ環境 (Lambda, Docker, PaaS) に応じて、`DISCORD_WEBHOOK_URL` などの環境変数を適切に設定します。
  * **状態の永続化:**
      * **サーバーレス環境:** `last_patch_status.json` を S3 (AWS Lambda) や Cloud Storage (Google Cloud Functions) などのオブジェクトストレージ、または Redis / DynamoDB などのキーバリューストアに保存するように `fileStorage.ts` を改修する必要があります。ファイルシステムは一時的なストレージであり、次回実行時に保持される保証がないためです。
      * **コンテナ/PaaS:** ボリュームマウントを使用して `last_patch_status.json` を永続化するか、同様に外部の永続化ストアを利用します。
  * **定期実行:**
      * **サーバーレス環境:** AWS EventBridge (CloudWatch Events) や Google Cloud Scheduler を使用して、関数を定期的にトリガーします。`node-cron` は不要になります。
      * **コンテナ/PaaS:** デプロイサービスの組み込みスケジューリング機能を利用するか、`node-cron` を使用し続けます（ただし、単一インスタンスでの実行を保証する設定が必要）。
  * **ログの集中管理:** CloudWatch Logs, Google Cloud Logging, Datadog など、デプロイ環境に応じたログ管理サービスにログを出力するようにロガーを設定します。