# League of Legends パッチノート Discord 通知システム 詳細設計書

## 4. 詳細設計 (コードロジックの概要)

### 4.1. ディレクトリ・ファイル構成案

```
/lol_patch_notifier_ts/
├── src/
│   ├── app.ts                  # アプリケーションのエントリポイント (定期実行ロジックを含む)
│   ├── config/
│   │   └── index.ts            # 環境変数/設定の読み込みと型定義
│   ├── services/
│   │   ├── PatchScraper.ts     # パッチノートページのスクレイピングロジック
│   │   └── DiscordNotifier.ts  # Discord Webhook 通知ロジック
│   ├── utils/
│   │   └── logger.ts           # ロギング設定とインスタンス
│   │   └── fileStorage.ts      # ファイルI/O (状態永続化用)
│   ├── types/
│   │   └── index.ts            # アプリケーション全体で利用する型定義
│   └── index.ts                # (オプション) `app.ts` をimportして起動する簡単なラッパー
├── .env.example                # 環境変数のサンプル (Git 管理対象)
├── .env                        # 実際の環境変数 (`.gitignore` 対象)
├── last_patch_status.json      # 最後に通知したパッチの情報をJSON形式で保存 (`.gitignore` 対象)
├── tsconfig.json               # TypeScript コンパイラ設定
├── package.json                # プロジェクト情報と依存関係
├── pnpm-lock.yaml              # パッケージロックファイル
├── .eslintrc.js                # ESLint 設定
├── .prettierrc                 # Prettier 設定
├── jest.config.js              # Jest 設定
└── README.md                   # プロジェクト説明書
```

### 4.2. コアロジックのコンポーネント

#### 4.2.1. `src/config/index.ts` (設定管理)

  * `dotenv` を使用して `.env` ファイルから環境変数をロードします。
  * `process.env` から必要な設定値 (例: `DISCORD_WEBHOOK_URL`, `LOL_PATCH_NOTES_URL`, `LAST_STATUS_FILE`) を取得し、型安全にエクスポートします。
  * 必須の設定値が不足している場合は、起動時にエラーをスローし、プログラムを終了します。

<!-- end list -->

```typescript
// src/config/index.ts
import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

// 環境変数スキーマ定義
const envSchema = z.object({
  DISCORD_WEBHOOK_URL: z.string().url('Invalid Discord webhook URL'),
  LOL_PATCH_NOTES_URL: z.string().url().default('https://www.leagueoflegends.com/ja-jp/news/game-updates/'),
  LAST_STATUS_FILE_PATH: z.string().default('./last_patch_status.json'),
  CHECK_INTERVAL_CRON: z.string().default('0 */90 * * *'), // Every 90 minutes
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  REQUEST_TIMEOUT_MS: z.coerce.number().min(1000).max(60000).default(30000),
  MAX_RETRIES: z.coerce.number().min(0).max(10).default(3),
  RATE_LIMIT_PER_HOUR: z.coerce.number().min(1).max(100).default(20),
});

// ランタイム検証と型安全性
const parseResult = envSchema.safeParse(process.env);

if (!parseResult.success) {
  console.error('環境変数の検証エラー:', parseResult.error.format());
  process.exit(1);
}

export const config = parseResult.data;
export type Config = z.infer<typeof envSchema>;

// 開発環境での設定チェック
if (config.NODE_ENV === 'development') {
  console.log('Development mode - 設定確認:', {
    webhookConfigured: !!config.DISCORD_WEBHOOK_URL,
    requestTimeout: config.REQUEST_TIMEOUT_MS,
    checkInterval: config.CHECK_INTERVAL_CRON,
  });
}
```

#### 4.2.2. `src/utils/logger.ts` (ロギング)

  * `winston` を使用して、コンソール出力やファイル出力など、柔軟なロギングを設定します。
  * ログレベル (debug, info, warn, error) に応じた出力を可能にします。

<!-- end list -->

```typescript
// src/utils/logger.ts
import pino from 'pino';
import { config } from '../config';

// 構造化ログ設定
const logger = pino({
  level: config.LOG_LEVEL,
  formatters: {
    level: (label) => ({ level: label.toUpperCase() }),
    bindings: (bindings) => ({
      pid: bindings.pid,
      hostname: bindings.hostname,
    }),
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  serializers: {
    error: pino.stdSerializers.err,
    req: pino.stdSerializers.req,
    res: pino.stdSerializers.res,
  },
  redact: {
    paths: ['*.password', '*.token', '*.key', '*.secret'],
    censor: '[REDACTED]',
  },
  ...(config.NODE_ENV === 'production' && {
    transport: {
      target: 'pino-cloudwatch',
      options: {
        logGroupName: '/aws/lambda/lol-patch-notifier',
        logStreamName: () => new Date().toISOString().split('T')[0],
      },
    },
  }),
});

// メトリクス用カウンタ
let errorCount = 0;
let requestCount = 0;

export const logMetrics = {
  incrementError: () => errorCount++,
  incrementRequest: () => requestCount++,
  getMetrics: () => ({ errorCount, requestCount }),
  resetMetrics: () => {
    errorCount = 0;
    requestCount = 0;
  },
};

// コンテキスト付きロガーラッパー
export const createContextLogger = (context: Record<string, unknown>) => {
  return logger.child(context);
};

export default logger;
```

#### 4.2.3. `src/utils/fileStorage.ts` (ファイル I/O)

  * `fs/promises` を使用し、状態の読み書きを行います。
  * ファイルの存在チェックやエラーハンドリングを含めます。

<!-- end list -->

```typescript
// src/utils/storage.ts
import { promises as fs } from 'fs';
import { z } from 'zod';
import logger from './logger';
import { config } from '../config';

// ストレージインターフェース
export interface Storage {
  read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null>;
  write<T>(key: string, data: T): Promise<void>;
  exists(key: string): Promise<boolean>;
}

// ファイルストレージ実装
export class FileStorage implements Storage {
  private readonly basePath: string;

  constructor(basePath = './data') {
    this.basePath = basePath;
  }

  async read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null> {
    const filePath = this.getFilePath(key);
    const contextLogger = logger.child({ operation: 'read', filePath });
    
    try {
      const data = await fs.readFile(filePath, 'utf-8');
      const parsed = JSON.parse(data);
      const validated = schema.parse(parsed);
      
      contextLogger.info('ファイル読み込み成功');
      return validated;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        contextLogger.info('ファイルが存在しません - 初回実行とみなします');
        return null;
      }
      contextLogger.error({ error }, 'ファイル読み込みエラー');
      throw new Error(`Storage read failed: ${error}`);
    }
  }

  async write<T>(key: string, data: T): Promise<void> {
    const filePath = this.getFilePath(key);
    const contextLogger = logger.child({ operation: 'write', filePath });
    
    try {
      // ディレクトリが存在しない場合は作成
      await fs.mkdir(this.basePath, { recursive: true });
      
      const jsonData = JSON.stringify(data, null, 2);
      await fs.writeFile(filePath, jsonData, 'utf-8');
      
      contextLogger.info('ファイル書き込み成功');
    } catch (error) {
      contextLogger.error({ error }, 'ファイル書き込みエラー');
      throw new Error(`Storage write failed: ${error}`);
    }
  }

  async exists(key: string): Promise<boolean> {
    try {
      await fs.access(this.getFilePath(key));
      return true;
    } catch {
      return false;
    }
  }

  private getFilePath(key: string): string {
    return `${this.basePath}/${key}.json`;
  }
}

// Redisストレージ実装 (サーバーレス環境用)
export class RedisStorage implements Storage {
  // Redisクライアントの実装は省略
  async read<T>(key: string, schema: z.ZodSchema<T>): Promise<T | null> {
    // Redisからデータを取得し、スキーマ検証を行う
    throw new Error('Redis storage not implemented');
  }

  async write<T>(key: string, data: T): Promise<void> {
    // Redisにデータを保存
    throw new Error('Redis storage not implemented');
  }

  async exists(key: string): Promise<boolean> {
    throw new Error('Redis storage not implemented');
  }
}

// ストレージファクトリ
export function createStorage(): Storage {
  if (config.NODE_ENV === 'production' && process.env.REDIS_URL) {
    return new RedisStorage();
  }
  return new FileStorage();
}
```

#### 4.2.4. `src/types/index.ts` (型定義)

  * アプリケーションで利用するデータ構造の型を定義します。

<!-- end list -->

```typescript
// src/types/index.ts
export interface PatchInfo {
    title: string;
    url: string;
}

export interface LastStatus {
    lastCheckedUrl: string;
    lastCheckedTimestamp: string;
}

export interface DiscordEmbed {
    title: string;
    url: string;
    description: string;
    color: number; // Decimal color code, e.g., 5814783 for purple
    timestamp?: string; // ISO 8601 format
}

export interface DiscordWebhookPayload {
    content?: string;
    embeds?: DiscordEmbed[];
}
```

#### 4.2.5. `src/services/PatchScraper.ts` (スクレイピングロジック)

  * 指定された URL から HTML を取得し、`cheerio` を使ってパッチノート情報を抽出します。
  * HTML 構造変更に備え、堅牢なセレクタを使用します。

<!-- end list -->

```typescript
// src/services/PatchScraper.ts
import axios from 'axios';
import * as cheerio from 'cheerio';
import { config } from '../config';
import logger from '../utils/logger';
import { PatchInfo } from '../types';

export class PatchScraper {
    private readonly baseUrl = 'https://www.leagueoflegends.com';

    public async getLatestPatchInfo(): Promise<PatchInfo | null> {
        try {
            logger.info(`Fetching patch notes from: ${config.lolPatchNotesUrl}`);
            const response = await axios.get(config.lolPatchNotesUrl, { timeout: 10000 }); // 10秒のタイムアウト
            const $ = cheerio.load(response.data);

            // 最新のゲームアップデート記事を特定 (data-content-type="game-updates" 属性を持つ最初のaタグ)
            const latestArticle = $('a[data-content-type="game-updates"]').first();

            if (!latestArticle.length) {
                logger.warn('No patch notes articles found with the specified selector.');
                return null;
            }

            const title = latestArticle.find('.news-card-title').text().trim();
            const relativeUrl = latestArticle.attr('href');

            if (!title || !relativeUrl) {
                logger.warn('Could not extract title or URL from the latest article.');
                return null;
            }

            const fullUrl = new URL(relativeUrl, this.baseUrl).toString(); // 絶対URLに変換

            logger.info(`Found latest patch: "${title}" at ${fullUrl}`);
            return { title, url: fullUrl };

        } catch (error: any) {
            logger.error(`Error scraping patch notes: ${error.message}`, error);
            if (axios.isAxiosError(error) && error.response) {
                logger.error(`HTTP Status: ${error.response.status}, Data: ${JSON.stringify(error.response.data)}`);
            }
            return null;
        }
    }
}
```

#### 4.2.6. `src/services/DiscordNotifier.ts` (Discord Webhook 通知)

  * Discord Webhook のペイロードを構築し、`axios` で送信します。
  * エラー発生時のロギングを含めます。

<!-- end list -->

```typescript
// src/services/DiscordNotifier.ts
import axios from 'axios';
import { config } from '../config';
import logger from '../utils/logger';
import { DiscordWebhookPayload, DiscordEmbed, PatchInfo } from '../types';

export class DiscordNotifier {
    public async sendNotification(patchInfo: PatchInfo): Promise<void> {
        const embed: DiscordEmbed = {
            title: patchInfo.title,
            url: patchInfo.url,
            description: '新しいLeague of Legendsパッチノートが公開されました！詳細はこちらからご確認ください。',
            color: 5814783, // Decimal for Discord purple
            timestamp: new Date().toISOString(), // ISO 8601 format
        };

        const payload: DiscordWebhookPayload = {
            content: '@everyone', // Discordで全員に通知したい場合
            embeds: [embed],
        };

        try {
            logger.info('Attempting to send Discord notification...');
            await axios.post(config.discordWebhookUrl, payload);
            logger.info('Discord notification sent successfully.');
        } catch (error: any) {
            logger.error(`Error sending Discord notification: ${error.message}`, error);
            if (axios.isAxiosError(error) && error.response) {
                logger.error(`Discord Webhook Status: ${error.response.status}, Response: ${JSON.stringify(error.response.data)}`);
            }
        }
    }
}
```

#### 4.2.7. `src/app.ts` (アプリケーション本体とスケジューリング)

  * 各種サービスを統合し、定期実行ロジックを実装します。
  * `node-cron` を使用してスケジュールを設定します。

<!-- end list -->

```typescript
// src/app.ts
import cron from 'node-cron';
import logger from './utils/logger';
import { config } from './config';
import { PatchScraper } from './services/PatchScraper';
import { DiscordNotifier } from './services/DiscordNotifier';
import { readJsonFile, writeJsonFile } from './utils/fileStorage';
import { LastStatus } from './types';

export class App {
    private patchScraper: PatchScraper;
    private discordNotifier: DiscordNotifier;
    private lastStatus: LastStatus | null = null;

    constructor() {
        this.patchScraper = new PatchScraper();
        this.discordNotifier = new DiscordNotifier();
    }

    public async init(): Promise<void> {
        logger.info('Application initializing...');
        this.lastStatus = await readJsonFile<LastStatus>(config.lastStatusFilePath);
        if (!this.lastStatus) {
            this.lastStatus = { lastCheckedUrl: '', lastCheckedTimestamp: '' };
            await writeJsonFile(config.lastStatusFilePath, this.lastStatus);
        }
        logger.info(`Last checked URL: ${this.lastStatus.lastCheckedUrl}`);
    }

    public async checkAndNotify(): Promise<void> {
        logger.info('Starting patch notes check...');
        try {
            const latestPatch = await this.patchScraper.getLatestPatchInfo();

            if (!latestPatch) {
                logger.warn('Could not retrieve latest patch info. Skipping notification.');
                return;
            }

            if (latestPatch.url !== this.lastStatus?.lastCheckedUrl) {
                logger.info(`New patch found! Title: "${latestPatch.title}", URL: ${latestPatch.url}`);
                await this.discordNotifier.sendNotification(latestPatch);

                this.lastStatus = {
                    lastCheckedUrl: latestPatch.url,
                    lastCheckedTimestamp: new Date().toISOString(),
                };
                await writeJsonFile(config.lastStatusFilePath, this.lastStatus);
            } else {
                logger.info('No new patch notes found. Current: ' + latestPatch.title);
            }
        } catch (error: any) {
            logger.error(`An unexpected error occurred during check: ${error.message}`, error);
        }
    }

    public startScheduler(): void {
        logger.info(`Scheduling patch notes check every: ${config.checkIntervalCron}`);
        cron.schedule(config.checkIntervalCron, () => {
            this.checkAndNotify();
        });
        logger.info('Scheduler started.');
    }
}

// 起動スクリプト
(async () => {
    const app = new App();
    await app.init();
    await app.checkAndNotify(); // アプリケーション起動時に一度実行
    app.startScheduler(); // その後、スケジュールに従って実行
})().catch(error => {
    logger.error(`Failed to start application: ${error.message}`, error);
    process.exit(1);
});
```