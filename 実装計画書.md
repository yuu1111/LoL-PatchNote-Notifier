# League of Legends パッチノート Discord 通知システム 実装計画書

## 概要

本書は、TypeScript/Node.jsベースのLoL パッチノート Discord 通知システムの段階的実装計画を示します。プロジェクトの現在の状態から本格運用まで、効率的かつ確実な実装経路を提供します。

## プロジェクト全体像

### システム構成
```
League of Legends パッチノート監視システム
     ↓ (HTTP スクレイピング)
公式パッチノートページ
     ↓ (新規検知)
Discord Webhook 通知
     ↓ (データ保存)
ローカルファイルシステム
```

### 主要コンポーネント
- **PatchScraper**: HTML解析とパッチノート情報抽出
- **DiscordNotifier**: Discord Webhook通知機能
- **ImageDownloader**: パッチノート画像のダウンロード・保存
- **State Management**: 状態管理とファイル永続化
- **Scheduler**: 定期実行と監視機能

---

## Phase 1: プロジェクト基盤構築

### Step 1-1: プロジェクト初期化
**目的**: 開発環境の準備とプロジェクト構造の構築

**実行内容**:
- Node.jsプロジェクトの初期化
- package.jsonの設定（依存関係、スクリプト、メタデータ）
- TypeScript設定（tsconfig.json）の構築
- ESLint・Prettierの設定
- Gitignore設定（.env、キャッシュファイル、ビルド結果の除外）

**完了条件**:
- npm installが正常に実行される
- TypeScriptコンパイルが正常に動作する
- コード品質ツールが機能する

### Step 1-2: ディレクトリ構造作成
**目的**: 設計書通りのファイル構成を実現

**実行内容**:
- srcディレクトリとサブディレクトリの作成
- patchesディレクトリの作成（データ保存用）
- 各モジュール用のファイル作成（空のTypeScriptファイル）
- 環境設定ファイル（.env.example）の作成

**完了条件**:
- 設計書で定義されたディレクトリ構造が完成
- 全ての必要なファイルが作成される

### Step 1-3: 基本設定とユーティリティ
**目的**: 共通機能とアプリケーション設定の実装

**実行内容**:
- 環境変数管理（config/index.ts）の実装
- ロギングシステム（utils/logger.ts）の実装
- HTTP クライアント（utils/httpClient.ts）の実装
- ファイル I/O（utils/fileStorage.ts）の実装
- TypeScript型定義（types/index.ts）の実装

**完了条件**:
- 設定が正しく読み込まれる
- ログが適切に出力される
- HTTP リクエストが実行できる
- ファイル読み書きが動作する

---

## Phase 2: コア機能実装

### Step 2-1: パッチノートスクレイピング機能
**目的**: Riot Gamesサイトからパッチノート情報を取得する機能の実装

**実行内容**:
- PatchScraperクラスの実装
- HTML取得とCheerioを使用した情報抽出
- パッチノートタイトル、URL、画像URLの抽出ロジック
- エラーハンドリングとリトライ機能
- 複数セレクタによるフォールバック機能

**完了条件**:
- 公式サイトから最新パッチノート情報が取得できる
- HTML構造の変更に対する堅牢性が確保される
- ネットワークエラーへの適切な対処ができる

### Step 2-2: 画像ダウンロード機能
**目的**: パッチノート画像の取得と永続保存機能の実装

**実行内容**:
- ImageDownloaderクラスの実装
- HTTP GETによるバイナリデータ取得
- 画像ファイルの拡張子判定
- ローカルファイルシステムへの保存
- 重複チェック機能

**完了条件**:
- パッチノート画像が正常にダウンロードされる
- 適切なファイル名で保存される
- 既存ファイルの上書き防止が機能する

### Step 2-3: Discord通知機能
**目的**: Discord Webhookを使用した通知システムの実装

**実行内容**:
- DiscordNotifierクラスの実装
- Discord Embed形式の通知メッセージ生成
- Webhook送信処理
- 画像添付機能
- エラーハンドリングと成功率追跡

**完了条件**:
- Discord チャンネルへの通知が正常に送信される
- パッチノート情報が適切にフォーマットされる
- 画像が正しく表示される

---

## Phase 3: 状態管理と統合

### Step 3-1: 状態管理システム
**目的**: パッチノート履歴とシステム状態の永続化

**実行内容**:
- JSONファイルベースの状態管理実装
- 最後に通知したパッチノートの記録
- パッチノート詳細データの保存
- データの整合性チェック機能

**完了条件**:
- 状態情報が正しくファイルに保存される
- アプリケーション再起動後も状態が保持される
- データの破損に対する復旧機能が動作する

### Step 3-2: メインアプリケーション統合
**目的**: 各コンポーネントを統合したメインアプリケーションの実装

**実行内容**:
- Appクラスの実装
- サービス間の連携処理
- 新規パッチノートの検知ロジック
- 通知フローの実装
- エラー処理と回復機能

**完了条件**:
- 新しいパッチノートが検知されると自動通知される
- 重複通知が防止される
- エラー発生時も適切に処理される

### Step 3-3: スケジューリング機能
**目的**: 定期実行による自動監視機能の実装

**実行内容**:
- node-cronを使用したスケジューラー実装
- 設定可能な実行間隔
- システム起動時の初回チェック
- スケジューラーの開始・停止制御

**完了条件**:
- 設定された間隔で定期的にパッチノートをチェックする
- システム起動時に即座にチェックが実行される
- スケジューラーが安定して動作する

---

## Phase 4: 品質保証とテスト

### Step 4-1: 単体テスト実装
**目的**: 各コンポーネントの動作確認とバグ防止

**実行内容**:
- Jestテスト環境の設定
- 各サービスクラスの単体テスト作成
- モック機能を使用した外部依存の分離
- エラーケースのテスト
- カバレッジ測定

**完了条件**:
- 主要機能の単体テストが実装される
- テストカバレッジが適切なレベルに達する
- CI/CDパイプラインでテストが実行される

### Step 4-2: 結合テスト実装
**目的**: システム全体の動作確認と統合テスト

**実行内容**:
- コンポーネント間の結合テスト
- 実際のHTTPリクエストを使用したテスト
- Discord Webhook送信テスト
- ファイルI/Oの結合テスト
- エラー回復シナリオのテスト

**完了条件**:
- システム全体が期待通りに動作する
- 外部サービスとの連携が正常に機能する
- 障害シナリオに対する適切な対処ができる

### Step 4-3: パフォーマンステスト
**目的**: システムの性能特性把握と最適化

**実行内容**:
- メモリ使用量の測定
- 処理時間の計測
- ネットワーク通信の効率性評価
- 長時間実行時の安定性確認
- リソース使用量の最適化

**完了条件**:
- システムが設計要件を満たす性能を発揮する
- メモリリークなどの問題が存在しない
- 長期間の連続実行が可能である

---

## Phase 5: 運用準備と本格稼働

### Step 5-1: 監視とログ強化
**目的**: 本番運用に必要な監視機能の実装

**実行内容**:
- 詳細なエラーログの実装
- 成功率とパフォーマンスメトリクスの収集
- アラート機能の実装
- ヘルスチェック機能の追加
- ログローテーション設定

**完了条件**:
- システムの健全性が監視できる
- 問題発生時に迅速に検知される
- 運用に必要な情報が適切にログ出力される

### Step 5-2: デプロイメント準備
**目的**: 本番環境への展開準備

**実行内容**:
- Docker化（必要に応じて）
- 環境別設定の整備
- デプロイスクリプトの作成
- バックアップと復旧手順の整備
- セキュリティ設定の確認

**完了条件**:
- 本番環境への安全なデプロイが可能になる
- 障害時の迅速な復旧手順が確立される
- セキュリティ要件が満たされる

### Step 5-3: ドキュメント整備
**目的**: 運用・保守に必要なドキュメントの完成

**実行内容**:
- README.mdの詳細化
- トラブルシューティングガイドの作成
- 設定項目の説明書作成
- アーキテクチャドキュメントの更新
- 運用手順書の作成

**完了条件**:
- 新しい開発者がプロジェクトを理解できる
- 運用担当者が適切にシステムを管理できる
- 問題発生時に迅速に対処できる

---

## Phase 6: 本格運用と継続改善

### Step 6-1: 本番稼働開始
**目的**: システムの本格運用開始

**実行内容**:
- 本番環境での初回動作確認
- 監視システムの有効化
- ユーザーへの通知開始
- 運用データの収集開始
- パフォーマンス監視の開始

**完了条件**:
- システムが安定して動作している
- 新しいパッチノートが確実に通知される
- 監視データが正常に収集される

### Step 6-2: 運用最適化
**目的**: 運用データに基づくシステム最適化

**実行内容**:
- パフォーマンスデータの分析
- エラー発生パターンの分析
- ユーザーフィードバックの収集
- システム設定の調整
- 不要な機能の削除や改善

**完了条件**:
- システムが最適な状態で動作している
- ユーザー满足度が向上している
- 運用コストが適切に管理されている

### Step 6-3: 機能拡張と継続改善
**目的**: 長期的な価値向上と機能拡張

**実行内容**:
- 新機能の企画・実装
- セキュリティアップデートの継続
- パフォーマンス改善の継続
- ユーザーリクエストへの対応
- 技術スタックの更新

**完了条件**:
- システムが継続的に価値を提供している
- セキュリティが維持されている
- 技術的負債が適切に管理されている

---

## 実装優先度とリスク管理

### 高優先度項目
1. **パッチノートスクレイピング機能** - システムの核心機能
2. **Discord通知機能** - ユーザー向け価値提供
3. **状態管理システム** - 重複通知防止のために必須
4. **エラーハンドリング** - システムの信頼性確保

### 中優先度項目
1. **画像ダウンロード機能** - ユーザーエクスペリエンス向上
2. **監視・ログ機能** - 運用安定性の向上
3. **テスト実装** - 品質保証とメンテナンス性

### 低優先度項目
1. **パフォーマンス最適化** - 基本機能実装後に実施
2. **高度な監視機能** - 安定運用後に追加
3. **機能拡張** - コア機能完成後に検討

### リスク要因と対策
1. **HTML構造変更リスク**: 複数セレクタによるフォールバック実装
2. **レート制限リスク**: 適切な間隔設定とリトライ機能
3. **Discord API変更リスク**: Webhook仕様の継続監視
4. **ネットワーク障害リスク**: 堅牢なエラーハンドリングと自動復旧

### 成功指標
- **信頼性**: 99.5%以上の通知成功率
- **応答性**: 新パッチノート公開から2時間以内の通知
- **安定性**: 30日間以上の連続稼働
- **保守性**: 新機能追加時の影響範囲最小化

---

---

## 進捗管理チェックリスト

### Phase 1: プロジェクト基盤構築
#### Step 1-1: プロジェクト初期化
- [ ] Node.jsプロジェクトの初期化完了
- [ ] package.json設定完了（依存関係、スクリプト定義）
- [ ] TypeScript設定（tsconfig.json）完了
- [ ] ESLint・Prettier設定完了
- [ ] .gitignore設定完了
- [ ] npm install正常実行確認
- [ ] TypeScriptコンパイル動作確認
- [ ] コード品質ツール動作確認

#### Step 1-2: ディレクトリ構造作成
- [ ] srcディレクトリ作成
- [ ] config/サブディレクトリ作成
- [ ] services/サブディレクトリ作成
- [ ] utils/サブディレクトリ作成
- [ ] types/サブディレクトリ作成
- [ ] patchesディレクトリ作成
- [ ] patches/images/サブディレクトリ作成
- [ ] 各モジュール用空ファイル作成
- [ ] .env.example作成

#### Step 1-3: 基本設定とユーティリティ
- [ ] config/index.ts実装完了
- [ ] utils/logger.ts実装完了
- [ ] utils/httpClient.ts実装完了
- [ ] utils/fileStorage.ts実装完了
- [ ] types/index.ts実装完了
- [ ] 設定読み込み動作確認
- [ ] ログ出力動作確認
- [ ] HTTP リクエスト動作確認
- [ ] ファイル読み書き動作確認

### Phase 2: コア機能実装
#### Step 2-1: パッチノートスクレイピング機能
- [ ] PatchScraperクラス基本構造実装
- [ ] HTML取得機能実装
- [ ] Cheerio使用情報抽出実装
- [ ] パッチノートタイトル抽出実装
- [ ] パッチノートURL抽出実装
- [ ] パッチノート画像URL抽出実装
- [ ] エラーハンドリング実装
- [ ] リトライ機能実装
- [ ] 複数セレクタフォールバック実装
- [ ] 公式サイトからの情報取得テスト
- [ ] HTML構造変更堅牢性テスト
- [ ] ネットワークエラー対処テスト

#### Step 2-2: 画像ダウンロード機能
- [ ] ImageDownloaderクラス基本構造実装
- [ ] HTTP GETバイナリデータ取得実装
- [ ] 画像拡張子判定実装
- [ ] ローカルファイル保存実装
- [ ] 重複チェック機能実装
- [ ] 画像ダウンロード動作確認
- [ ] ファイル名生成動作確認
- [ ] 上書き防止機能確認

#### Step 2-3: Discord通知機能
- [ ] DiscordNotifierクラス基本構造実装
- [ ] Discord Embed生成実装
- [ ] Webhook送信処理実装
- [ ] 画像添付機能実装
- [ ] エラーハンドリング実装
- [ ] 成功率追跡実装
- [ ] Discord通知送信テスト
- [ ] メッセージフォーマット確認
- [ ] 画像表示確認

### Phase 3: 状態管理と統合
#### Step 3-1: 状態管理システム
- [ ] JSONファイル状態管理実装
- [ ] 最終通知パッチノート記録実装
- [ ] パッチノート詳細データ保存実装
- [ ] データ整合性チェック実装
- [ ] 状態ファイル保存確認
- [ ] アプリケーション再起動状態保持確認
- [ ] データ破損復旧機能確認

#### Step 3-2: メインアプリケーション統合
- [ ] Appクラス基本構造実装
- [ ] サービス間連携処理実装
- [ ] 新規パッチノート検知ロジック実装
- [ ] 通知フロー実装
- [ ] エラー処理・回復機能実装
- [ ] 新規パッチノート自動通知確認
- [ ] 重複通知防止確認
- [ ] エラー発生時処理確認

#### Step 3-3: スケジューリング機能
- [ ] node-cronスケジューラー実装
- [ ] 実行間隔設定機能実装
- [ ] システム起動時初回チェック実装
- [ ] スケジューラー制御実装
- [ ] 定期チェック動作確認
- [ ] 起動時即座チェック確認
- [ ] スケジューラー安定動作確認

### Phase 4: 品質保証とテスト
#### Step 4-1: 単体テスト実装
- [ ] Jest環境設定完了
- [ ] PatchScraperテスト実装
- [ ] DiscordNotifierテスト実装
- [ ] ImageDownloaderテスト実装
- [ ] 状態管理テスト実装
- [ ] モック機能実装
- [ ] エラーケーステスト実装
- [ ] カバレッジ測定設定
- [ ] 単体テスト実行確認
- [ ] カバレッジ目標達成確認

#### Step 4-2: 結合テスト実装
- [ ] コンポーネント間結合テスト実装
- [ ] 実HTTPリクエストテスト実装
- [ ] Discord Webhook送信テスト実装
- [ ] ファイルI/O結合テスト実装
- [ ] エラー回復シナリオテスト実装
- [ ] システム全体動作確認
- [ ] 外部サービス連携確認
- [ ] 障害シナリオ対処確認

#### Step 4-3: パフォーマンステスト
- [ ] メモリ使用量測定実装
- [ ] 処理時間計測実装
- [ ] ネットワーク効率評価実装
- [ ] 長時間実行安定性確認
- [ ] リソース使用量最適化実装
- [ ] 性能要件満足確認
- [ ] メモリリーク問題排除確認
- [ ] 長期連続実行確認

### Phase 5: 運用準備と本格稼働
#### Step 5-1: 監視とログ強化
- [ ] 詳細エラーログ実装
- [ ] メトリクス収集実装
- [ ] アラート機能実装
- [ ] ヘルスチェック機能実装
- [ ] ログローテーション設定
- [ ] システム健全性監視確認
- [ ] 問題検知機能確認
- [ ] 運用情報ログ出力確認

#### Step 5-2: デプロイメント準備
- [ ] Docker化実装（必要時）
- [ ] 環境別設定整備
- [ ] デプロイスクリプト作成
- [ ] バックアップ手順整備
- [ ] 復旧手順整備
- [ ] セキュリティ設定確認
- [ ] 本番デプロイ可能性確認
- [ ] 復旧手順確立確認
- [ ] セキュリティ要件満足確認

#### Step 5-3: ドキュメント整備
- [ ] README.md詳細化
- [ ] トラブルシューティングガイド作成
- [ ] 設定項目説明書作成
- [ ] アーキテクチャドキュメント更新
- [ ] 運用手順書作成
- [ ] 新規開発者理解可能性確認
- [ ] 運用担当者管理可能性確認
- [ ] 迅速問題対処可能性確認

### Phase 6: 本格運用と継続改善
#### Step 6-1: 本番稼働開始
- [ ] 本番環境初回動作確認
- [ ] 監視システム有効化
- [ ] ユーザー通知開始
- [ ] 運用データ収集開始
- [ ] パフォーマンス監視開始
- [ ] システム安定動作確認
- [ ] パッチノート確実通知確認
- [ ] 監視データ正常収集確認

#### Step 6-2: 運用最適化
- [ ] パフォーマンスデータ分析
- [ ] エラー発生パターン分析
- [ ] ユーザーフィードバック収集
- [ ] システム設定調整
- [ ] 不要機能削除・改善
- [ ] システム最適状態達成
- [ ] ユーザー満足度向上確認
- [ ] 運用コスト適切管理確認

#### Step 6-3: 機能拡張と継続改善
- [ ] 新機能企画・実装
- [ ] セキュリティアップデート継続
- [ ] パフォーマンス改善継続
- [ ] ユーザーリクエスト対応
- [ ] 技術スタック更新
- [ ] 継続価値提供確認
- [ ] セキュリティ維持確認
- [ ] 技術負債適切管理確認

---

## 進捗管理について

この実装計画書には、AI開発者（Claude Code）が効率的に進捗を管理できるよう、各Phase・Step内に詳細なチェックボックスを用意しています。

### チェックボックス活用方法
- **逐次更新**: 各タスク完了時に対応するチェックボックスにチェックを入れる
- **進捗可視化**: 未完了項目を明確に把握し、次の作業優先度を決定する
- **品質保証**: 各ステップの完了条件をチェックリストで確認する
- **コミュニケーション**: チーム間での進捗共有に活用する

### 管理上の利点
- **作業漏れ防止**: 細分化されたタスクにより実装漏れを防止
- **継続性確保**: セッション間での作業継続性を保持
- **品質維持**: 各段階での品質チェックポイントを明確化
- **効率向上**: 次に実施すべき作業の迅速な特定

---

## 結論

本実装計画書は、LoL パッチノート Discord 通知システムを段階的かつ確実に構築するための詳細な道筋を示しています。Phase 1からPhase 6まで順次実装することで、高品質で保守性の高いシステムを構築できます。

各フェーズは独立性を保ちながらも、前のフェーズの成果物を基盤として発展させる構造となっており、開発リスクを最小化しながら価値あるシステムを構築することが可能です。

詳細なチェックリストにより、AI開発者が効率的に進捗を管理し、確実な実装を進められる体制が整備されています。